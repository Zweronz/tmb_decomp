"""
Environment constants used across the build system scripts.
"""

import dataclasses

from pathlib import Path

from .strenum import StrEnum

_CROSS = "mips-linux-gnu-"


class Version(StrEnum):
    """
    Versions of the game available to decompile/build.
    """

    US = "US"

    def get_basename(self) -> str:
        """
        Get the binary basename corresponding to this version of the game.
        """
        return "SCUS_971.01"


@dataclasses.dataclass
class EnvironmentDirectories:
    """
    Dataclass for core repository directories used in the build.
    """

    # Root of the repository.
    root: Path
    # Disks directory which contains the binary to disassemble/match against.
    disks: Path
    # Tools directory.
    tools: Path
    # Config directory where the `splat` configuration can be found.
    config: Path
    # Build directory which contains objects and the final built ELF.
    build: Path
    # Directory for split ASM.
    asm: Path
    # Directory for source code.
    src: Path
    # Directory for split assets/binary files.
    assets: Path
    # Directory for nonmatching code.
    nonmatchings: Path
    # List of include directories. These should be relative to the root.
    includes: list[Path]
    # List of include directories which should be considered "system includes" by
    # the build system.
    system_includes: list[Path]

    @staticmethod
    def for_version(version: Version, root: Path) -> "EnvironmentDirectories":
        """
        Construct the directory paths for the build using the given
        Path pointing to the root of the repository.
        """
        return EnvironmentDirectories(
            root=root,
            disks=root / "disks",
            tools=root / "tools",
            config=root / f"config/{version}",
            build=root / "build",
            asm=root / "asm",
            src=root / "src",
            assets=root / "assets",
            nonmatchings=root / "asm/nonmatchings",
            includes=[Path("include")],
            system_includes=[
                Path("include/gcc"),
                Path("include/gcc/gcc-lib"),
                Path("include/sdk"),
            ],
        )


@dataclasses.dataclass
class EnvironmentFiles:
    """
    Dataclass for core files required for, used, or created as part of the build.
    """

    # Path to the `splat` YAML file.
    splat_yaml: Path
    # Path to the `splat` cache.
    splat_cache: Path
    # Path to the `splat` symbols.
    splat_symbols: Path
    # Path to the linker script generated by `splat` for the binary.
    ldscript: Path
    # Path to the mapfile which should be generated by the build.
    ldmap: Path
    # Path to the `build.ninja` file created and executed by the build.
    build_script: Path
    # Path to the original executable to disassemble/compare against.
    disk: Path
    # Path to the ELF file generated by the linker script after build.
    pre_elf: Path
    # Path to the final ELF file which should match the original binary.
    final_elf: Path

    @staticmethod
    def for_version(
        version: Version, directories: EnvironmentDirectories, basename: str
    ) -> "EnvironmentFiles":
        """
        Construct the file variables for the build using the given binary version,
        directory layout, and the base name of the binary.
        """

        return EnvironmentFiles(
            splat_yaml=directories.config / f"{basename}.yaml",
            splat_cache=directories.config / ".splache",
            splat_symbols=directories.config / "symbol_addrs.txt",
            ldscript=directories.config / f"{basename}.ld",
            ldmap=directories.build / f"{basename}.map",
            build_script=directories.root / "build.ninja",
            disk=directories.disks / basename,
            pre_elf=directories.build / f"{basename}.elf",
            final_elf=directories.build / basename,
        )


@dataclasses.dataclass
class EnvironmentToolchain:
    """
    Dataclass for compilers and tools used in the build.
    """

    # Path/CLI name of C compiler tool.
    c_compiler_cmd: str
    # Path/CLI name of C++ compiler tool.
    cxx_compiler_cmd: str
    # Path/CLI name of assembler.
    assembler_cmd: str
    # Path/CLI name of linker.
    linker_cmd: str
    # Path/CLI name of GNU objcopy.
    objcopy_cmd: str
    # Path/CLI name of GNU strip.
    strip_cmd: str
    # Path/CLI name of C preprocessor tool.
    c_preprocessor_cmd: str

    # Value of $gp register in the binary.
    gp_value: int

    # Base flags for C compilation, ignoring includes.
    c_flags: list[str]
    # Base flags for C++ compilation, ignoring includes.
    cxx_flags: list[str]
    # Base flags for assembler invocation, ignoring includes.
    as_flags: list[str]
    # Base flags for linker invocation.
    ld_flags: list[str]

    @staticmethod
    def for_version(
        version: Version, directories: EnvironmentDirectories, files: EnvironmentFiles
    ) -> "EnvironmentToolchain":
        """
        Construct the toolchain variables for the build using the given
        binary version and the compiler directory in the repository.
        """
        compiler = str(directories.tools / "ee-gcc2.9/bin/ee-gcc")

        return EnvironmentToolchain(
            c_compiler_cmd=compiler,
            cxx_compiler_cmd=compiler,
            assembler_cmd=f"{_CROSS}as",
            linker_cmd=f"{_CROSS}ld",
            objcopy_cmd=f"{_CROSS}objcopy",
            strip_cmd=f"{_CROSS}strip",
            c_preprocessor_cmd=f"{_CROSS}cpp",
            gp_value=0x004FEE70,
            c_flags=["-O2", "-G8"],
            cxx_flags=[
                "-O2",
                "-G8",
                "-x c++",
            ],
            as_flags=[
                "-EL",
                "-march=5900",
                "-G0",
                "-no-pad-sections",
                "-mabi=eabi",
            ],
            ld_flags=[
                "-EL",
                f"-T {directories.config / 'undefined_syms_auto.txt'}",
                f"-T {directories.config / 'undefined_funcs.txt'}",
                f"-Map {files.ldmap}",
                "-nostdlib",
            ],
        )


@dataclasses.dataclass
class Environment:
    # Version of the binary to build/disassemble.
    version: Version
    # "Base name" of the project and original binary.
    basename: str
    # Important directories in the repository.
    directories: EnvironmentDirectories
    # Important files in the repository.
    files: EnvironmentFiles
    # Toolchain variables for the build.
    toolchain: EnvironmentToolchain

    def previously_split(self) -> bool:
        """
        Determine if split/disassembly artifacts currently exist in the repository.
        """
        return (
            self.directories.asm.is_dir()
            and self.directories.assets.is_dir()
            and self.files.ldscript.is_file()
            and self.files.splat_cache.is_file()
        )

    def previously_built(self) -> bool:
        """
        Determine if build artifacts currently exist in the repository.
        """
        return self.directories.build.is_dir()

    def generate_c_compiler_cmd(self) -> str:
        """
        Generate the full C compiler invocation for this environment, not including
        input/output parameters.
        """
        flags = [
            *[f"-I{inc}" for inc in self.directories.includes],
            *[f"-isystem {inc}" for inc in self.directories.system_includes],
            *self.toolchain.c_flags,
        ]
        return f"{self.toolchain.c_compiler_cmd} -c {' '.join(flags)}"

    def generate_cxx_compiler_cmd(self) -> str:
        """
        Generate the full C++ compiler invocation for this environment, not including
        input/output parameters.
        """
        flags = [
            *[f"-I{inc}" for inc in self.directories.includes],
            *[f"-isystem {inc}" for inc in self.directories.system_includes],
            *self.toolchain.cxx_flags,
        ]
        return f"{self.toolchain.cxx_compiler_cmd} -c {' '.join(flags)}"

    def generate_assembler_cmd(self) -> str:
        """
        Generate the full AS assembler invocation for this environment, not including
        input/output parameters.
        """
        flags = [
            *[f"-I{inc}" for inc in self.directories.includes],
            *self.toolchain.as_flags,
        ]
        return f"{self.toolchain.assembler_cmd} {' '.join(flags)}"

    def generate_linker_cmd(self) -> str:
        """
        Generate the full LD linker invocation for this environment, not including
        input/output parameters.
        """
        return f"{self.toolchain.linker_cmd} {' '.join(self.toolchain.ld_flags)}"

    @staticmethod
    def for_version(version: Version, root: Path) -> "Environment":
        """
        Given the version of the binary to build/disassemble and the path to the
        root of the repository, construct variables for the build environment.
        """
        basename = version.get_basename()
        directories = EnvironmentDirectories.for_version(version, root)
        files = EnvironmentFiles.for_version(version, directories, basename)
        toolchain = EnvironmentToolchain.for_version(version, directories, files)

        return Environment(
            version=version,
            basename=basename,
            directories=directories,
            files=files,
            toolchain=toolchain,
        )
